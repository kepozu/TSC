{
  "version": "1.0.0",
  "description": "Core logic for the Musical Time Signature Compensation Calculator. Contains self-contained Python code for calculation, verification, and chart generation.",
  "modules": {
    "shared_code": "import math\nfrom collections.abc import Mapping, Sequence\nfrom dataclasses import dataclass\nfrom fractions import Fraction\nfrom typing import ClassVar\n\nimport flet as ft\n\nWHOLE_NOTE_BEAT_COUNT: int = 4\n\n@dataclass(frozen=True)\nclass MeasureGroup:\n    numerator: int\n    denominator: int\n    count: int\n\n@dataclass(frozen=True)\nclass UIMeasureGroup(MeasureGroup):\n    id: int\n\n@dataclass(frozen=True)\nclass CalculationResult:\n    measures: dict[str, int]\n    user_denominator: int\n    explanation: list[str]\n    fallback_used: bool\n\n@dataclass(frozen=True)\nclass ChartConfig:\n    data_series: list[ft.LineChartData]\n    max_x: float\n    max_y: float\n    bottom_axis: ft.ChartAxis\n    left_axis: ft.ChartAxis\n",
    "calculator_code": "class CompensationCalculator:\n    MAX_NUMERATOR: ClassVar[int] = 32\n    EXCLUDED_NUMERATOR: ClassVar[int] = 4\n\n    @classmethod\n    def _calculate_primary_compensation(\n        cls, ideal_beat_compensation: int, explanation: list[str]\n    ) -> tuple[dict[str, int], list[str]]:\n        explanation.extend([\n            (\n                '\\nResult: Using ideal compensation value '\n                f'm = {ideal_beat_compensation} (since m > 0).'\n            ),\n            (\n                'This beat count will be divided into an efficient combination '\n                'of measures.'\n            ),\n            (\n                f'Available time signatures: 1/4 to {cls.MAX_NUMERATOR}/4 '\n                f'(excluding {cls.EXCLUDED_NUMERATOR}/4)'\n            ),\n        ])\n        available_numerators = [\n            n for n in range(cls.MAX_NUMERATOR, 0, -1)\n            if n != cls.EXCLUDED_NUMERATOR\n        ]\n        remaining_beats = ideal_beat_compensation\n        compensation_measures: dict[str, int] = {}\n        explanation.append('\\nDivision Calculation:')\n        for num in available_numerators:\n            if remaining_beats >= num:\n                count = remaining_beats // num\n                compensation_measures[f'{num}/4'] = count\n                remaining_beats %= num\n                explanation.append(\n                    f'  Using {count} measure(s) of {num}/4 '\n                    f'(Remaining: {remaining_beats} beats)'\n                )\n            if remaining_beats == 0:\n                break\n        return compensation_measures, explanation\n\n    @classmethod\n    def _calculate_fallback_compensation(\n        cls, total_beats: int, total_measures: int, explanation: list[str]\n    ) -> tuple[dict[str, int], list[str]]:\n        explanation.extend([\n            (\n                '\\nFallback Goal: Insert additional measures to align the '\n                'entire timeline to a \"Total Beats = 4 * Total Measures\" '\n                'structure.'\n            )\n        ])\n        excess_beats = total_beats - (WHOLE_NOTE_BEAT_COUNT * total_measures)\n        explanation.extend([\n            '\\nExcess Beat Calculation (based on 4/4 time):',\n            (\n                f'  Excess Beats = S - 4*Σkᵢ = {total_beats} - '\n                f'4*{total_measures} = {excess_beats}'\n            ),\n        ])\n        if excess_beats <= 0:\n            message = (\n                '\\nNo additional measures are needed as there are no excess '\n                'beats.' if excess_beats == 0 else\n                '\\nWarning: Timeline is deficient but does not meet primary '\n                'goal conditions.'\n            )\n            explanation.append(message)\n            return {}, explanation\n        explanation.extend([\n            (\n                'This excess will be absorbed by the fewest possible '\n                'additional measures.'\n            ),\n            (\n                'Priority is given to signatures that absorb more beats '\n                '(i.e., have a larger difference from 4/4 time).'\n            ),\n            '  - Adding one 1/4 measure absorbs 3 beats (4-1=3).',\n            '  - Adding one 2/4 measure absorbs 2 beats (4-2=2).',\n            '  - Adding one 3/4 measure absorbs 1 beat (4-3=1).',\n        ])\n        remainder = excess_beats\n        n_1_4 = remainder // 3\n        remainder %= 3\n        n_2_4 = remainder // 2\n        remainder %= 2\n        n_3_4 = remainder\n        suggestion = {}\n        if n_1_4 > 0:\n            suggestion['1/4'] = n_1_4\n        if n_2_4 > 0:\n            suggestion['2/4'] = n_2_4\n        if n_3_4 > 0:\n            suggestion['3/4'] = n_3_4\n        explanation.extend([\n            '\\nSuggestion Calculation:',\n            (\n                f'  Number of 1/4 measures (absorbs 3 beats): '\n                f'{excess_beats} // 3 = {n_1_4}'\n            ),\n            f'  (Remaining: {excess_beats % 3})',\n            (\n                f'  Number of 2/4 measures (absorbs 2 beats): '\n                f'{excess_beats % 3} // 2 = {n_2_4}'\n            ),\n            f'  (Remaining: {(excess_beats % 3) % 2})',\n            (\n                f'  Number of 3/4 measures (absorbs 1 beat): '\n                f'{(excess_beats % 3) % 2} // 1 = {n_3_4}'\n            ),\n        ])\n        s_add = (1 * n_1_4) + (2 * n_2_4) + (3 * n_3_4)\n        k_add = n_1_4 + n_2_4 + n_3_4\n        s_new = total_beats + s_add\n        k_new = total_measures + k_add\n        target_beats = WHOLE_NOTE_BEAT_COUNT * k_new\n        explanation.extend([\n            '\\nVerification:',\n            f'  Suggested additional measures: {suggestion}',\n            f'  Added Beats S_add = {s_add}, Added Measures k_add = {k_add}',\n            (\n                f'  New Total Beats S_new = {s_new}, New Total Measures k_new '\n                f'= {k_new}'\n            ),\n            f'  Target Beats = 4 * k_new = {target_beats}',\n            (\n                '  S_new matches 4 * k_new, aligning the timeline.'\n                if s_new == target_beats else\n                '  Verification mismatch - check the logic.'\n            ),\n        ])\n        return suggestion, explanation\n\n    @classmethod\n    def calculate(\n        cls, added_groups: Sequence[MeasureGroup]\n    ) -> CalculationResult:\n        if not added_groups:\n            return CalculationResult(\n                measures={},\n                user_denominator=4,\n                explanation=['Error: No groups have been added.'],\n                fallback_used=False,\n            )\n        for i, group in enumerate(added_groups):\n            if not all(\n                isinstance(val, int) and val > 0\n                for val in [group.numerator, group.denominator, group.count]\n            ):\n                raise ValueError(f'Group {i} contains non-positive integers.')\n        try:\n            total_beats = sum(\n                (g.numerator * WHOLE_NOTE_BEAT_COUNT * g.count) // g.denominator\n                for g in added_groups\n            )\n            total_measures = sum(g.count for g in added_groups)\n        except ZeroDivisionError as e:\n            raise ValueError(\n                'Invalid group data: denominator cannot be zero.'\n            ) from e\n        denominators = [g.denominator for g in added_groups]\n        user_denominator = max(set(denominators), key=denominators.count)\n        explanation = [\n            'Calculation Steps:',\n            '--------------------',\n            'Added Groups:',\n        ]\n        for i, group in enumerate(added_groups):\n            group_beats = (\n                group.numerator * WHOLE_NOTE_BEAT_COUNT * group.count\n            ) // group.denominator\n            explanation.append(\n                f'  Group {i+1}: {group.numerator}/{group.denominator} x '\n                f'{group.count} measures -> {group_beats} beats'\n            )\n        explanation.extend([\n            '--------------------',\n            f'Total Inserted Measures (Σkᵢ) = {total_measures}',\n            f'Total Inserted Beats (S) = {total_beats}',\n            '--------------------',\n        ])\n        if total_beats == WHOLE_NOTE_BEAT_COUNT * total_measures:\n            explanation.extend([\n                '\\nStructural Analysis:',\n                f'  Total Beats ({total_beats}) is exactly 4 times Total '\n                f'Measures ({total_measures}).',\n                '  The timeline is already perfectly balanced.',\n                '\\nResult: No compensation is required.',\n            ])\n            return CalculationResult(\n                measures={},\n                user_denominator=user_denominator,\n                explanation=explanation,\n                fallback_used=False,\n            )\n        ideal_beat_compensation = (\n            WHOLE_NOTE_BEAT_COUNT * (total_measures + 1) - total_beats\n        )\n        explanation.extend([\n            'Primary Goal: Align total beats to 4 * (Total Measures + 1)',\n            'Ideal Compensation Beats (m) Formula:',\n            '  m = 4 * (1 + Σkᵢ) - S',\n            (\n                f'  m = 4 * (1 + {total_measures}) - {total_beats} = '\n                f'{ideal_beat_compensation}'\n            ),\n        ])\n        if ideal_beat_compensation > 0:\n            result, explanation = cls._calculate_primary_compensation(\n                ideal_beat_compensation, explanation\n            )\n            return CalculationResult(\n                measures=result,\n                user_denominator=user_denominator,\n                explanation=explanation,\n                fallback_used=False,\n            )\n        else:\n            explanation.append(\n                f'\\nResult: Ideal value m ({ideal_beat_compensation}) is not '\n                'positive, using fallback logic.'\n            )\n            result, explanation = cls._calculate_fallback_compensation(\n                total_beats, total_measures, explanation\n            )\n            return CalculationResult(\n                measures=result,\n                user_denominator=user_denominator,\n                explanation=explanation,\n                fallback_used=True,\n            )\n",
    "verifier_code": "class VerificationEngine:\n    @staticmethod\n    def _lcm(a: int, b: int) -> int:\n        return abs(a * b) // math.gcd(a, b) if a != 0 and b != 0 else 0\n\n    @staticmethod\n    def verify_beat_conservation(\n        added_groups: Sequence[MeasureGroup],\n        compensation_result: Mapping[str, int],\n        fallback_used: bool,\n    ) -> tuple[bool, list[str]]:\n        explanation = ['=== Beat Conservation Verification ===']\n        try:\n            total_added_beats = sum(\n                (g.numerator * WHOLE_NOTE_BEAT_COUNT * g.count) // g.denominator\n                for g in added_groups\n            )\n            total_added_measures = sum(g.count for g in added_groups)\n        except (AttributeError, ZeroDivisionError, TypeError) as e:\n            explanation.append(f'FAIL: Invalid added_groups data: {e}')\n            return False, explanation\n        explanation.append(f'Added groups total beats: {total_added_beats}')\n        explanation.append(\n            f'Added groups total measures: {total_added_measures}'\n        )\n        compensation_beats = 0\n        compensation_measures = 0\n        try:\n            for measure_str, count in compensation_result.items():\n                if '/' in measure_str:\n                    num, den = map(int, measure_str.split('/'))\n                    compensation_beats += (\n                        num * WHOLE_NOTE_BEAT_COUNT * count\n                    ) // den\n                    compensation_measures += count\n        except (ValueError, ZeroDivisionError) as e:\n            explanation.append(f'FAIL: Invalid compensation_result data: {e}')\n            return False, explanation\n        explanation.append(f'Compensation beats: {compensation_beats}')\n        explanation.append(f'Compensation measures: {compensation_measures}')\n        total_beats = total_added_beats + compensation_beats\n        total_measures = total_added_measures + compensation_measures\n        if fallback_used:\n            target_beats = WHOLE_NOTE_BEAT_COUNT * total_measures\n            explanation.append(\n                f'Fallback target: 4 * {total_measures} = {target_beats}'\n            )\n        elif not compensation_result:\n            target_beats = total_added_beats\n            explanation.append(\n                'Primary target (no compensation needed): '\n                f'Timeline is self-balanced at {target_beats} beats.'\n            )\n        else:\n            target_beats = WHOLE_NOTE_BEAT_COUNT * (total_added_measures + 1)\n            explanation.append(\n                f'Primary target: 4 * ({total_added_measures} + 1) = '\n                f'{target_beats}'\n            )\n        is_valid = total_beats == target_beats\n        explanation.append(f'Actual total beats: {total_beats}')\n        explanation.append(f'Target beats: {target_beats}')\n        explanation.append(\n            f\"Conservation check: {'PASS' if is_valid else 'FAIL'}\"\n        )\n        return is_valid, explanation\n\n    @staticmethod\n    def verify_mathematical_constraints(\n        added_groups: Sequence[MeasureGroup],\n        compensation_result: Mapping[str, int],\n        fallback_used: bool,\n    ) -> tuple[bool, list[str]]:\n        explanation = ['=== Mathematical Constraints Verification ===']\n        is_valid = True\n        for i, group in enumerate(added_groups):\n            if not all(\n                val > 0\n                for val in [group.numerator, group.denominator, group.count]\n            ):\n                explanation.append(\n                    f'FAIL: Group {i+1} has non-positive values.'\n                )\n                is_valid = False\n            if group.denominator > 0 and (\n                group.denominator & (group.denominator - 1)\n            ) != 0:\n                explanation.append(\n                    f'WARNING: Group {i+1} denominator {group.denominator} '\n                    'is not a power of 2.'\n                )\n        for measure_str, count in compensation_result.items():\n            if count <= 0:\n                explanation.append(\n                    f'FAIL: Compensation measure {measure_str} has '\n                    'non-positive count.'\n                )\n                is_valid = False\n                continue\n            if '/' in measure_str:\n                try:\n                    num, den = map(int, measure_str.split('/'))\n                    if num <= 0 or den <= 0:\n                        explanation.append(\n                            f'FAIL: Compensation measure {measure_str} has '\n                            'invalid signature.'\n                        )\n                        is_valid = False\n                    if den > 0 and (den & (den - 1)) != 0:\n                        explanation.append(\n                            f'WARNING: Compensation denominator {den} is not '\n                            'a power of 2.'\n                        )\n                except ValueError:\n                    explanation.append(\n                        f'FAIL: Invalid measure format: {measure_str}.'\n                    )\n                    is_valid = False\n        try:\n            total_beats_fraction = sum(\n                Fraction(\n                    g.numerator * WHOLE_NOTE_BEAT_COUNT * g.count, g.denominator\n                ) for g in added_groups\n            )\n            for measure_str, count in compensation_result.items():\n                if '/' in measure_str:\n                    num, den = map(int, measure_str.split('/'))\n                    total_beats_fraction += Fraction(\n                        num * WHOLE_NOTE_BEAT_COUNT * count, den\n                    )\n            explanation.append(\n                f'Precise total beats (fraction): {total_beats_fraction}'\n            )\n            if total_beats_fraction.denominator != 1:\n                explanation.append(\n                    'FAIL: Total beats is not an integer, indicating a '\n                    'calculation error.'\n                )\n                is_valid = False\n            else:\n                explanation.append('PASS: Total beats is an integer.')\n        except (ValueError, ZeroDivisionError) as e:\n            explanation.append(f'FAIL: Fraction calculation error: {e}')\n            is_valid = False\n        explanation.append(\n            f\"Constraint check: {'PASS' if is_valid else 'FAIL'}\"\n        )\n        return is_valid, explanation\n\n    @classmethod\n    def verify_alternative_calculation(\n        cls,\n        added_groups: Sequence[MeasureGroup],\n        compensation_result: Mapping[str, int],\n        fallback_used: bool,\n    ) -> tuple[bool, list[str]]:\n        explanation = ['=== Alternative Calculation Verification ===']\n        try:\n            all_denominators = [\n                g.denominator for g in added_groups if g.denominator > 0\n            ]\n            for measure_str in compensation_result:\n                if '/' in measure_str:\n                    _, den = map(int, measure_str.split('/'))\n                    if den > 0:\n                        all_denominators.append(den)\n        except (AttributeError, ValueError) as e:\n            explanation.append(f'FAIL: Error collecting denominators: {e}')\n            return False, explanation\n        if not all_denominators:\n            explanation.append('No denominators found for LCM calculation.')\n            return True, explanation\n        common_denominator = 1\n        for den in all_denominators:\n            common_denominator = cls._lcm(common_denominator, den)\n        explanation.append(\n            'Common denominator for precise calculation: '\n            f'{common_denominator}'\n        )\n        try:\n            total_beats_precise = 0\n            total_added_measures = 0\n            total_compensation_measures = 0\n            for group in added_groups:\n                total_beats_precise += (\n                    group.numerator\n                    * (common_denominator // group.denominator)\n                    * group.count\n                )\n                total_added_measures += group.count\n            for measure_str, count in compensation_result.items():\n                if '/' in measure_str:\n                    num, den = map(int, measure_str.split('/'))\n                    total_beats_precise += (\n                        num * (common_denominator // den) * count\n                    )\n                    total_compensation_measures += count\n            total_beats_quarter = (\n                total_beats_precise * WHOLE_NOTE_BEAT_COUNT\n            ) // common_denominator\n        except (ZeroDivisionError, ValueError) as e:\n            explanation.append(f'FAIL: Alternative calculation error: {e}')\n            return False, explanation\n        explanation.append(\n            f'Total beats (quarter notes) via LCM: {total_beats_quarter}'\n        )\n        if fallback_used:\n            total_measures = total_added_measures + total_compensation_measures\n            expected_beats = WHOLE_NOTE_BEAT_COUNT * total_measures\n        elif not compensation_result:\n            expected_beats = (\n                WHOLE_NOTE_BEAT_COUNT * total_added_measures\n            )\n        else:\n            expected_beats = WHOLE_NOTE_BEAT_COUNT * (total_added_measures + 1)\n        explanation.append(f'Expected beats: {expected_beats}')\n        is_valid = total_beats_quarter == expected_beats\n        explanation.append(\n            f\"Alternative calculation: {'PASS' if is_valid else 'FAIL'}\"\n        )\n        return is_valid, explanation\n\n    @staticmethod\n    def verify_structural_integrity(\n        added_groups: Sequence[MeasureGroup],\n        compensation_result: Mapping[str, int],\n        fallback_used: bool,\n    ) -> tuple[bool, list[str]]:\n        explanation = ['=== Structural Integrity Verification ===']\n        is_valid = True\n        try:\n            total_beats = sum(\n                (g.numerator * WHOLE_NOTE_BEAT_COUNT * g.count) // g.denominator\n                for g in added_groups\n            )\n            total_measures = sum(g.count for g in added_groups)\n            ideal_m = (\n                WHOLE_NOTE_BEAT_COUNT * (total_measures + 1) - total_beats\n            )\n        except (AttributeError, ZeroDivisionError) as e:\n            explanation.append(f'FAIL: Error calculating ideal_m: {e}')\n            return False, explanation\n        explanation.append(f'Calculated ideal_m: {ideal_m}')\n        explanation.append(f'Fallback used: {fallback_used}')\n        is_self_balanced = (\n            total_beats == WHOLE_NOTE_BEAT_COUNT * total_measures\n        )\n        if not compensation_result and not fallback_used:\n            if is_self_balanced:\n                explanation.append(\n                    'PASS: Correctly identified self-balanced timeline.'\n                )\n            else:\n                explanation.append(\n                    'FAIL: No compensation returned for an unbalanced timeline.'\n                )\n                is_valid = False\n        elif fallback_used:\n            if ideal_m > 0:\n                explanation.append('FAIL: Fallback used when ideal_m > 0.')\n                is_valid = False\n            else:\n                explanation.append('PASS: Correctly selected fallback logic.')\n        else:\n            if ideal_m <= 0:\n                explanation.append(\n                    'FAIL: Primary logic used when ideal_m <= 0.'\n                )\n                is_valid = False\n            elif is_self_balanced:\n                explanation.append(\n                    'FAIL: Primary logic used on a self-balanced timeline.'\n                )\n                is_valid = False\n            else:\n                explanation.append(\n                    'PASS: Correctly selected primary compensation logic.'\n                )\n        if fallback_used:\n            allowed_fallback = {'1/4', '2/4', '3/4'}\n            invalid_measures = set(compensation_result.keys()) - allowed_fallback\n            if invalid_measures:\n                explanation.append(\n                    'FAIL: Invalid fallback measures found: '\n                    f'{invalid_measures}.'\n                )\n                is_valid = False\n        explanation.append(\n            f\"Structural integrity: {'PASS' if is_valid else 'FAIL'}\"\n        )\n        return is_valid, explanation\n",
    "chart_generator_code": "class TimelineChartGenerator:\n    @staticmethod\n    def _get_axis_labels(\n        max_val: float, is_x_axis: bool\n    ) -> list[ft.ChartAxisLabel]:\n        if max_val <= 1:\n            return [ft.ChartAxisLabel(value=1, label=ft.Text('1'))]\n        if max_val <= 10:\n            step = 1\n        elif max_val <= 50:\n            step = 5\n        else:\n            step = 10 * round(max_val / 100)\n        step = max(1, step)\n        labels = []\n        for i in range(step, int(max_val) + step, step):\n            label_text = f\"{i}{'m' if is_x_axis else 'b'}\"\n            labels.append(\n                ft.ChartAxisLabel(value=i, label=ft.Text(label_text, size=11))\n            )\n        return labels\n\n    @classmethod\n    def generate_chart_data(\n        cls,\n        added_groups: Sequence[UIMeasureGroup],\n        compensation_result: Mapping[str, int],\n    ) -> ChartConfig:\n        if not added_groups and not compensation_result:\n            raise ValueError(\n                'Both added_groups and compensation_result are empty.'\n            )\n        all_measures = []\n        try:\n            for group in added_groups:\n                measure = {'num': group.numerator, 'den': group.denominator}\n                all_measures.extend([measure] * group.count)\n            for measure_str, count in compensation_result.items():\n                if '/' in measure_str:\n                    num, den = map(int, measure_str.split('/'))\n                    measure = {'num': num, 'den': den}\n                    all_measures.extend([measure] * count)\n        except (AttributeError, ValueError, TypeError) as e:\n            raise ValueError(\n                f'Invalid input data for chart generation: {e}'\n            ) from e\n        if not all_measures and not added_groups:\n            raise ValueError('No valid measures found for chart generation.')\n        actual_points = [ft.LineChartDataPoint(0, 0)]\n        cumulative_beats = 0.0\n        cumulative_measures = 0\n        for measure in all_measures:\n            cumulative_measures += 1\n            try:\n                beats_in_measure = (\n                    measure['num'] * WHOLE_NOTE_BEAT_COUNT\n                ) / measure['den']\n                cumulative_beats += beats_in_measure\n                actual_points.append(\n                    ft.LineChartDataPoint(cumulative_measures, cumulative_beats)\n                )\n            except ZeroDivisionError:\n                raise ValueError(\n                    f'Invalid measure with zero denominator: {measure}'\n                )\n        total_measures = cumulative_measures\n        total_beats = cumulative_beats\n        ideal_beats = WHOLE_NOTE_BEAT_COUNT * total_measures\n        ideal_points = [\n            ft.LineChartDataPoint(0, 0),\n            ft.LineChartDataPoint(total_measures, ideal_beats),\n        ]\n        uncompensated_points = [ft.LineChartDataPoint(0, 0)]\n        cumulative_added_beats = 0.0\n        cumulative_added_measures = 0\n        if added_groups:\n            for group in added_groups:\n                for _ in range(group.count):\n                    cumulative_added_measures += 1\n                    beats_in_measure = (\n                        group.numerator * WHOLE_NOTE_BEAT_COUNT\n                    ) / group.denominator\n                    cumulative_added_beats += beats_in_measure\n                    uncompensated_points.append(\n                        ft.LineChartDataPoint(\n                            cumulative_added_measures, cumulative_added_beats\n                        )\n                    )\n        num_compensation_measures = sum(compensation_result.values(), 0)\n        final_uncompensated_beats = cumulative_added_beats\n        if num_compensation_measures > 0:\n            projected_beats = num_compensation_measures * WHOLE_NOTE_BEAT_COUNT\n            final_uncompensated_beats += projected_beats\n            final_projected_measure = (\n                cumulative_added_measures + num_compensation_measures\n            )\n            uncompensated_points.append(\n                ft.LineChartDataPoint(\n                    final_projected_measure, final_uncompensated_beats\n                )\n            )\n        data_series = [\n            ft.LineChartData(\n                data_points=actual_points,\n                color='#f9d2d7',\n                stroke_width=4,\n                curved=True,\n                stroke_cap_round=True,\n            ),\n            ft.LineChartData(\n                data_points=uncompensated_points,\n                color='#e83743',\n                stroke_width=2,\n                curved=True,\n                stroke_cap_round=True,\n            ),\n            ft.LineChartData(\n                data_points=ideal_points,\n                color=ft.Colors.with_opacity(0.5, ft.Colors.ON_SURFACE),\n                stroke_width=2,\n                dash_pattern=[4, 4],\n            ),\n        ]\n        max_x = max(1, total_measures)\n        max_y = math.ceil(\n            max(total_beats, ideal_beats, final_uncompensated_beats) * 1.1\n        )\n        max_y = max(4, max_y)\n        return ChartConfig(\n            data_series=data_series,\n            max_x=float(max_x),\n            max_y=float(max_y),\n            bottom_axis=ft.ChartAxis(\n                labels=cls._get_axis_labels(max_x, True), labels_size=30\n            ),\n            left_axis=ft.ChartAxis(\n                labels=cls._get_axis_labels(max_y, False), labels_size=40\n            ),\n        )\n"
  }
}